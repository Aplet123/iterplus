var iterplusLib;iterplusLib=(()=>{"use strict";var t={593:function(t,e,n){var r=this&&this.__await||function(t){return this instanceof r?(this.v=t,this):new r(t)},i=this&&this.__asyncGenerator||function(t,e,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,o=n.apply(t,e||[]),l=[];return i={},a("next"),a("throw"),a("return"),i[Symbol.asyncIterator]=function(){return this},i;function a(t){o[t]&&(i[t]=function(e){return new Promise((function(n,r){l.push([t,e,n,r])>1||s(t,e)}))})}function s(t,e){try{(n=o[t](e)).value instanceof r?Promise.resolve(n.value.v).then(u,c):f(l[0][2],n)}catch(t){f(l[0][3],t)}var n}function u(t){s("next",t)}function c(t){s("throw",t)}function f(t,e){t(e),l.shift(),l.length&&s(l[0][0],l[0][1])}},o=this&&this.__asyncValues||function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t="function"==typeof __values?__values(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(n){e[n]=t[n]&&function(e){return new Promise((function(r,i){!function(t,e,n,r){Promise.resolve(r).then((function(e){t({value:e,done:n})}),e)}(r,i,(e=t[n](e)).done,e.value)}))}}},l=this&&this.__asyncDelegator||function(t){var e,n;return e={},i("next"),i("throw",(function(t){throw t})),i("return"),e[Symbol.iterator]=function(){return this},e;function i(i,o){e[i]=t[i]?function(e){return(n=!n)?{value:r(t[i](e)),done:"return"===i}:o?o(e):e}:o}};Object.defineProperty(e,"__esModule",{value:!0}),e.AsyncPeekable=e.AsyncIterPlus=e.canAsyncIter=e.isAsyncIter=void 0;const a=n(715),s=n(143);e.isAsyncIter=function(t){return"object"==typeof t&&null!==t&&"function"==typeof t.next},e.canAsyncIter=function(t){return"object"==typeof t&&null!==t&&Symbol.asyncIterator in t};const u=n(715);class c{constructor(t){this.internal=t}async next(){return await this.internal.next()}async nextVal(){const t=await this.internal.next();return t.done?u.nullVal:t.value}[Symbol.asyncIterator](){return this}static empty(){return new c(function(){return i(this,arguments,(function*(){}))}())}static fromFunction(t){return new c(function(){return i(this,arguments,(function*(){for(;;){const e=yield r(t());if(e===u.nullVal)break;yield yield r(e)}}))}())}static onceWith(t){return new c(function(){return i(this,arguments,(function*(){yield yield r(yield r(t()))}))}())}static once(t){return new c(function(){return i(this,arguments,(function*(){yield yield r(yield r(t))}))}())}static repeatWith(t){return new c(function(){return i(this,arguments,(function*(){for(;;)yield yield r(yield r(t()))}))}())}static repeat(t){return new c(function(){return i(this,arguments,(function*(){for(;;)yield yield r(yield r(t))}))}())}static successors(t,e){return new c(function(){return i(this,arguments,(function*(){let n=yield r(t);for(;n!==u.nullVal;)yield yield r(n),n=yield r(e(n))}))}())}static unfold(t,e){return new c(function(){return i(this,arguments,(function*(){let n=yield r(e);for(;;){const e=yield r(t(n));if(e===u.nullVal)break;yield yield r(e[0]),n=e[1]}}))}())}static cycle(t){return new c(function(){return i(this,arguments,(function*(){var e,n;const i=[];try{for(var a,s=o(t);!(a=yield r(s.next())).done;){const t=a.value;yield yield r(t),i.push(t)}}catch(t){e={error:t}}finally{try{a&&!a.done&&(n=s.return)&&(yield r(n.call(s)))}finally{if(e)throw e.error}}for(;;)yield r(yield*l(o(i)))}))}())}static combinations(t,e=t.length){return new c(function(){return i(this,arguments,(function*(){if(e>t.length||e<0)return yield r(void 0);const n=[];for(let t=0;t<e;t++)n.push(t);for(;;){let e;for(yield yield r(n.map((e=>t[e]))),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-e-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=n[n.length-e-2]+1,e--}}))}())}static combinationsWithRepetition(t,e=t.length){return new c(function(){return i(this,arguments,(function*(){if(t.length<=0||e<0)return yield r(void 0);const n=[];for(let t=0;t<e;t++)n.push(0);for(;;){let e;for(yield yield r(n.map((e=>t[e]))),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=n[n.length-e-2],e--}}))}())}static permutations(t,e=t.length){return new c(function(){return i(this,arguments,(function*(){if(e>t.length||e<0)return yield r(void 0);if(0===e)return yield yield r([]),yield r(void 0);const n=[],i=[];for(let e=0;e<t.length;e++)n.push(e);for(let n=t.length;n>t.length-e;n--)i.push(n);for(yield yield r(n.slice(0,e).map((e=>t[e])));;){let o;for(o=e-1;o>=0;o--){if(i[o]--,0!==i[o]){const l=n[o];n[o]=n[n.length-i[o]],n[n.length-i[o]]=l,yield yield r(n.slice(0,e).map((e=>t[e])));break}{const e=n[o];for(let t=o;t<n.length-1;t++)n[t]=n[t+1];n[n.length-1]=e,i[o]=t.length-o}}if(o<0)return yield r(void 0)}}))}())}static permutationsWithRepetition(t,e=t.length){return new c(function(){return i(this,arguments,(function*(){if(t.length<=0||e<0)return yield r(void 0);if(0===e)return yield yield r([]),yield r(void 0);const n=[];for(let t=0;t<e;t++)n.push(0);for(;;){let e;for(yield yield r(n.map((e=>t[e]))),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=0,e--}}))}())}static powerset(t){return new c(function(){return i(this,arguments,(function*(){for(let e=0;e<=t.length;e++)yield r(yield*l(o(c.combinations(t,e))))}))}())}static product(...t){return new c(function(){return i(this,arguments,(function*(){if(t.length<=0)return yield r(void 0);const e=[];for(let n=0;n<t.length;n++){if(0===t[n].length)return yield r(void 0);e.push(0)}for(;;){let n;for(yield yield r(e.map(((e,n)=>t[n][e]))),n=0;n<e.length;n++)if(e[t.length-n-1]<t[t.length-n-1].length-1){e[t.length-n-1]++;break}if(n===e.length)break;for(n--;n>=0;)e[t.length-n-1]=0,n--}}))}())}async every(t){var e,n;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value;if(!await t(e))return!1}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}return!0}async some(t){var e,n;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value;if(await t(e))return!0}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}return!1}concat(...t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;for(const s of[e,...t])try{for(var l,a=(n=void 0,o(s));!(l=yield r(a.next())).done;){const t=l.value;yield yield r(t)}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}async compareBy(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(t.done&&r.done)return 0;if(t.done)return-1;if(r.done)return 1;{const n=await e(t.value,r.value);if(n<0)return-1;if(n>0)return 1}}}async compareWith(t,e){return this.compareBy(t,(async function(t,n){const r=await e(t),i=await e(n);return r<i?-1:r>i?1:0}))}async compare(t){return this.compareBy(t,(async function(t,e){return t<e?-1:t>e?1:0}))}async collect(){var t,e;const n=[];try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;n.push(t)}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}async count(){var t,e;let n=0;try{for(var r,i=o(this);!(r=await i.next()).done;)r.value,n++}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}enumerate(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;let i=0;try{for(var l,a=o(t);!(l=yield r(a.next())).done;){const t=l.value;yield yield r([i,t]),i++}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&(yield r(n.call(a)))}finally{if(e)throw e.error}}}))}())}async equalsBy(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(t.done&&r.done)return!0;if(t.done||r.done)return!1;if(!await e(t.value,r.value))return!1}}async equalsWith(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(t.done&&r.done)return!0;if(t.done||r.done)return!1;if(await e(t.value)!==await e(r.value))return!1}}async equals(t){const e=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),n=await e.next();if(t.done&&n.done)return!0;if(t.done||n.done)return!1;if(t.value!==n.value)return!1}}filter(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value;(yield r(t(e)))&&(yield yield r(e))}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}filterMap(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value,n=yield r(t(e));n!==u.nullVal&&(yield yield r(n))}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}async find(t){var e,n;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value;if(await t(e))return e}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}return u.nullVal}async findMap(t){var e,n;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value,n=await t(e);if(n!==u.nullVal)return n}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}return u.nullVal}flatten(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;try{for(var i,a=o(t);!(i=yield r(a.next())).done;){const t=i.value;yield r(yield*l(o(t)))}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=a.return)&&(yield r(n.call(a)))}finally{if(e)throw e.error}}}))}())}map(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value;yield yield r(yield r(t(e)))}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}starmap(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value;yield yield r(yield r(t(...e)))}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}flatMap(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var a,s=o(e);!(a=yield r(s.next())).done;){const e=a.value;yield r(yield*l(o(yield r(t(e)))))}}catch(t){n={error:t}}finally{try{a&&!a.done&&(i=s.return)&&(yield r(i.call(s)))}finally{if(n)throw n.error}}}))}())}async reduce(t,e){var n,r;let i;if(void 0===e){const t=await this.next();if(t.done)throw new TypeError("Reduce of empty iterator with no initializer.");i=t.value}else i=e;try{for(var l,a=o(this);!(l=await a.next()).done;){const e=l.value;i=await t(i,e)}}catch(t){n={error:t}}finally{try{l&&!l.done&&(r=a.return)&&await r.call(a)}finally{if(n)throw n.error}}return i}async forEach(t){var e,n;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value;await t(e)}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}}fuse(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;try{for(var i,l=o(t);!(i=yield r(l.next())).done;){const t=i.value;yield yield r(t)}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&(yield r(n.call(l)))}finally{if(e)throw e.error}}}))}())}inspect(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value;yield r(t(e)),yield yield r(e)}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}async isPartitioned(t){var e,n;let r=!1;try{for(var i,l=o(this);!(i=await l.next()).done;){const e=i.value;if(await t(e)){if(r)return!1}else r=!0}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return!0}async isSortedBy(t){var e,n;const r=await this.next();if(r.done)return!0;let i=r.value;try{for(var l,a=o(this);!(l=await a.next()).done;){const e=l.value;if(await t(i,e)>0)return!1;i=e}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&await n.call(a)}finally{if(e)throw e.error}}return!0}async isSortedWith(t){var e,n;const r=await this.next();if(r.done)return!0;let i=await t(r.value);try{for(var l,a=o(this);!(l=await a.next()).done;){const e=l.value,n=await t(e);if(i>n)return!1;i=n}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&await n.call(a)}finally{if(e)throw e.error}}return!0}isSorted(){return this.isSortedWith((async t=>t))}async last(){var t,e;let n=u.nullVal;try{for(var r,i=o(this);!(r=await i.next()).done;)n=r.value}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}mapWhile(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;try{for(var l,a=o(e);!(l=yield r(a.next())).done;){const e=l.value,n=yield r(t(e));if(null===n)break;yield yield r(n)}}catch(t){n={error:t}}finally{try{l&&!l.done&&(i=a.return)&&(yield r(i.call(a)))}finally{if(n)throw n.error}}}))}())}async maxBy(t,e=!1){var n,r;const i=await this.next();if(i.done)return null;let l=i.value;try{for(var a,s=o(this);!(a=await s.next()).done;){const n=a.value,r=await t(n,l);(r>0||e&&0===r)&&(l=n)}}catch(t){n={error:t}}finally{try{a&&!a.done&&(r=s.return)&&await r.call(s)}finally{if(n)throw n.error}}return l}async maxWith(t,e=!1){var n,r;const i=await this.next();if(i.done)return null;let l=i.value,a=await t(l);try{for(var s,u=o(this);!(s=await u.next()).done;){const n=s.value,r=await t(n);(r>a||e&&r===a)&&(l=n,a=r)}}catch(t){n={error:t}}finally{try{s&&!s.done&&(r=u.return)&&await r.call(u)}finally{if(n)throw n.error}}return l}max(t=!1){return this.maxWith((async t=>t),t)}async minBy(t,e=!1){var n,r;const i=await this.next();if(i.done)return null;let l=i.value;try{for(var a,s=o(this);!(a=await s.next()).done;){const n=a.value,r=await t(n,l);(r<0||e&&0===r)&&(l=n)}}catch(t){n={error:t}}finally{try{a&&!a.done&&(r=s.return)&&await r.call(s)}finally{if(n)throw n.error}}return l}async minWith(t,e=!1){var n,r;const i=await this.next();if(i.done)return null;let l=i.value,a=await t(l);try{for(var s,u=o(this);!(s=await u.next()).done;){const n=s.value,r=await t(n);(r<a||e&&r===a)&&(l=n,a=r)}}catch(t){n={error:t}}finally{try{s&&!s.done&&(r=u.return)&&await r.call(u)}finally{if(n)throw n.error}}return l}min(t=!1){return this.minWith((async t=>t),t)}async nth(t){var e,n;if(t<0)return u.nullVal;try{for(var r,i=o(this);!(r=await i.next()).done;){const e=r.value;if(t<=0)return e;t--}}catch(t){e={error:t}}finally{try{r&&!r.done&&(n=i.return)&&await n.call(i)}finally{if(e)throw e.error}}return u.nullVal}async partition(t){var e,n;const r=[],i=[];try{for(var l,a=o(this);!(l=await a.next()).done;){const e=l.value;await t(e)?r.push(e):i.push(e)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&await n.call(a)}finally{if(e)throw e.error}}return[r,i]}peekable(){return new f(this)}async findIndex(t){var e,n;let r=0;try{for(var i,l=o(this);!(i=await l.next()).done;){const e=i.value;if(await t(e))return r;r++}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return-1}async product(t=1){var e,n;let r,i=!1;try{for(var l,a=o(this);!(l=await a.next()).done;){const t=l.value;i?r*=t:(r=t,i=!0)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&await n.call(a)}finally{if(e)throw e.error}}return void 0===r?t:r}async sum(t=0){var e,n;let r,i=!1;try{for(var l,a=o(this);!(l=await a.next()).done;){const t=l.value;i?r+=t:(r=t,i=!0)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&await n.call(a)}finally{if(e)throw e.error}}return void 0===r?t:r}async reverse(){var t,e;const n=[];try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;n.push(t)}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return new a.IterPlus(n.reverse().values())}skip(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(let n=0;n<t;n++)if((yield r(e.next())).done)return yield r(void 0);yield r(yield*l(o(e)))}))}())}skipWhile(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(;;){const n=yield r(e.next());if(n.done)return yield r(void 0);if(!t(n.value)){yield yield r(n.value);break}}yield r(yield*l(o(e)))}))}())}take(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(let n=0;n<t;n++){const t=yield r(e.next());if(t.done)return yield r(void 0);yield yield r(t.value)}}))}())}takeWhile(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(;;){const n=yield r(e.next());if(n.done)return yield r(void 0);if(!t(n.value))return yield r(void 0);yield yield r(n.value)}}))}())}async unzip(){var t,e;const n=[];try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;for(;t.length>n.length;)n.push([]);for(let e=0;e<t.length;e++)n[e].push(t[e])}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}zipWith(t,...e){const n=this;return new c(function(){return i(this,arguments,(function*(){const i=[n,...e.map((t=>t[Symbol.asyncIterator]()))];for(;;){const e=[];for(const t of i){const n=yield r(t.next());if(n.done)return yield r(void 0);e.push(n.value)}yield yield r(yield r(t(...e)))}}))}())}zip(...t){const e=this;return new c(function(){return i(this,arguments,(function*(){const n=[e,...t.map((t=>t[Symbol.asyncIterator]()))];for(;;){const t=[];for(const e of n){const n=yield r(e.next());if(n.done)return yield r(void 0);t.push(n.value)}yield yield r(t)}}))}())}tee(t=2){if(t<=0)return[];const e=new s.CircularBuffer;let n=0,o=!1;const l=this,a=[],u=[];function f(t){return i(this,arguments,(function*(){let i=0;for(;;){if(i>=n+e.size()){if(o)return yield r(void 0);const t=yield r(l.next());if(t.done)return o=!0,yield r(void 0);e.pushEnd(t.value),yield yield r(t.value)}else{yield yield r(e.get(i-n));const t=Math.min(...u);for(;t>n;)n++,e.popStart()}i++,u[t]=i}}))}for(let e=0;e<t;e++)u.push(0),a.push(new c(f(e)));return a}async average(){var t,e;let n=0,r=!1,i=!1,l=0;try{for(var a,s=o(this);!(a=await s.next()).done;){const t=a.value;r||("bigint"==typeof t&&(i=!0,n=BigInt(n)),r=!0),n+=t,l++}}catch(e){t={error:e}}finally{try{a&&!a.done&&(e=s.return)&&await e.call(s)}finally{if(t)throw t.error}}if(i&&(l=BigInt(l)),0===l)throw new RangeError("Cannot average an empty iterator.");return n/l}chunks(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(;;){const n=[];for(let i=0;i<t;i++){const t=yield r(e.next());if(t.done)return n.length>0&&(yield yield r(n)),yield r(void 0);n.push(t.value)}yield yield r(n)}}))}())}chunksExact(t){const e=this;return new c(function(){return i(this,arguments,(function*(){for(;;){const n=[];for(let i=0;i<t;i++){const i=yield r(e.next());if(i.done)return n.length===t&&(yield yield r(n)),yield r(void 0);n.push(i.value)}yield yield r(n)}}))}())}repeat(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const a=[];try{for(var s,u=o(e);!(s=yield r(u.next())).done;){const t=s.value;a.push(t)}}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=u.return)&&(yield r(i.call(u)))}finally{if(n)throw n.error}}if(0===a.length)return yield r(void 0);for(let e=0;e<t;e++)yield r(yield*l(o(a)))}))}())}rotateLeft(t){if(t<0)throw new RangeError("Cannot left rotate by a negative amount.");const e=this;return new c(function(){return i(this,arguments,(function*(){const n=[];for(let i=0;i<t;i++){const i=yield r(e.next());if(i.done)return n.length>0&&(t%=n.length,yield r(yield*l(o([...n.slice(t),...n.slice(0,t)])))),yield r(void 0);n.push(i.value)}yield r(yield*l(o(e))),yield r(yield*l(o(n)))}))}())}rotateRight(t){if(t<0)throw new RangeError("Cannot right rotate by a negative amount.");const e=this;return new c(function(){return i(this,arguments,(function*(){const n=[];for(;;){const t=yield r(e.next());if(t.done)break;n.push(t.value)}n.length>0&&(t%=n.length,yield r(yield*l(o([...n.slice(-t),...n.slice(0,-t)]))))}))}())}split(t,e=1/0){const n=this;return new c(function(){return i(this,arguments,(function*(){const i=yield r(t);let o=!1,l=1,a=[];for(;;){const t=yield r(n.next());if(t.done){o&&(yield yield r(a));break}o=!0,l<e&&t.value===i?(yield yield r(a),a=[],l++):a.push(t.value)}}))}())}splitPred(t,e=1/0){const n=this;return new c(function(){return i(this,arguments,(function*(){let i=!1,o=1,l=[];for(;;){const a=yield r(n.next());if(a.done){i&&(yield yield r(l));break}i=!0,o<e&&(yield r(t(a.value)))?(yield yield r(l),l=[],o++):l.push(a.value)}}))}())}splitInclusive(t,e=1/0){const n=this;return new c(function(){return i(this,arguments,(function*(){const i=yield r(t);let o=!1,l=1,a=[];for(;;){const t=yield r(n.next());if(t.done){o&&a.length>0&&(yield yield r(a));break}o=!0,a.push(t.value),l<e&&t.value===i&&(yield yield r(a),a=[],l++)}}))}())}splitPredInclusive(t,e=1/0){const n=this;return new c(function(){return i(this,arguments,(function*(){let i=!1,o=1,l=[];for(;;){const a=yield r(n.next());if(a.done){i&&l.length>0&&(yield yield r(l));break}i=!0,l.push(a.value),o<e&&(yield r(t(a.value)))&&(yield yield r(l),l=[],o++)}}))}())}windows(t,e=1){const n=this;return new c(function(){return i(this,arguments,(function*(){const i=new s.CircularBuffer;for(let e=0;e<t;e++){const t=yield r(n.next());if(t.done)return yield r(void 0);i.pushEnd(t.value)}for(;;){yield yield r(i.toArray());for(let t=0;t<e;t++){const t=yield r(n.next());if(t.done)return yield r(void 0);i.popStart(),i.pushEnd(t.value)}}}))}())}dedup(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;const i=yield r(t.next());if(i.done)return yield r(void 0);yield yield r(i.value);let l=i.value;try{for(var a,s=o(t);!(a=yield r(s.next())).done;){const t=a.value;t!==l&&(yield yield r(t)),l=t}}catch(t){e={error:t}}finally{try{a&&!a.done&&(n=s.return)&&(yield r(n.call(s)))}finally{if(e)throw e.error}}}))}())}dedupWith(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const l=yield r(e.next());if(l.done)return yield r(void 0);yield yield r(l.value);let a=yield r(t(l.value));try{for(var s,u=o(e);!(s=yield r(u.next())).done;){const e=s.value,n=yield r(t(e));n!==a&&(yield yield r(e)),a=n}}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=u.return)&&(yield r(i.call(u)))}finally{if(n)throw n.error}}}))}())}dedupBy(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const l=yield r(e.next());if(l.done)return yield r(void 0);yield yield r(l.value);let a=l.value;try{for(var s,u=o(e);!(s=yield r(u.next())).done;){const e=s.value;t(a,e)||(yield yield r(e)),a=e}}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=u.return)&&(yield r(i.call(u)))}finally{if(n)throw n.error}}}))}())}intersperse(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const l=yield r(t),a=yield r(e.next());if(a.done)return yield r(void 0);yield yield r(a.value);try{for(var s,u=o(e);!(s=yield r(u.next())).done;){const t=s.value;yield yield r(l),yield yield r(t)}}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=u.return)&&(yield r(i.call(u)))}finally{if(n)throw n.error}}}))}())}intersperseMultiple(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i,a,s;const u=[];try{for(var c,f=o(t);!(c=yield r(f.next())).done;){const t=c.value;u.push(t)}}catch(t){n={error:t}}finally{try{c&&!c.done&&(i=f.return)&&(yield r(i.call(f)))}finally{if(n)throw n.error}}const d=yield r(e.next());if(d.done)return yield r(void 0);yield yield r(d.value);try{for(var y,h=o(e);!(y=yield r(h.next())).done;){const t=y.value;yield r(yield*l(o(u))),yield yield r(t)}}catch(t){a={error:t}}finally{try{y&&!y.done&&(s=h.return)&&(yield r(s.call(h)))}finally{if(a)throw a.error}}}))}())}join(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const a=yield r(t),s=yield r(e.next());if(s.done)return yield r(void 0);yield r(yield*l(o(s.value)));try{for(var u,c=o(e);!(u=yield r(c.next())).done;){const t=u.value;yield yield r(a),yield r(yield*l(o(t)))}}catch(t){n={error:t}}finally{try{u&&!u.done&&(i=c.return)&&(yield r(i.call(c)))}finally{if(n)throw n.error}}}))}())}joinMultiple(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i,a,s;const u=[];try{for(var c,f=o(t);!(c=yield r(f.next())).done;){const t=c.value;u.push(t)}}catch(t){n={error:t}}finally{try{c&&!c.done&&(i=f.return)&&(yield r(i.call(f)))}finally{if(n)throw n.error}}const d=yield r(e.next());if(d.done)return yield r(void 0);yield r(yield*l(o(d.value)));try{for(var y,h=o(e);!(y=yield r(h.next())).done;){const t=y.value;yield r(yield*l(o(u))),yield r(yield*l(o(t)))}}catch(t){a={error:t}}finally{try{y&&!y.done&&(s=h.return)&&(yield r(s.call(h)))}finally{if(a)throw a.error}}}))}())}async toObject(t="overwrite"){var e,n;const r={};try{for(var i,l=o(this);!(i=await l.next()).done;){const[e,n]=i.value;if("overwrite"!==t&&e in r){if("error"===t)throw new RangeError("Duplicate key encountered.");"maintain"===t||(r[e]=n)}else r[e]=n}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return r}async toMap(t="overwrite"){var e,n;const r=new Map;try{for(var i,l=o(this);!(i=await l.next()).done;){const[e,n]=i.value;if("overwrite"!==t&&r.has(e)){if("error"===t)throw new RangeError("Duplicate key encountered.");"maintain"===t||r.set(e,n)}else r.set(e,n)}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return r}async toSet(){var t,e;const n=new Set;try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;n.add(t)}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}async toArray(){var t,e;const n=[];try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;n.push(t)}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}interleave(...t){const e=this;return new c(function(){return i(this,arguments,(function*(){const n=[e,...t.map((t=>t[Symbol.asyncIterator]()))].map((t=>({done:!1,iter:t})));for(;;){let t=!1;for(const e of n){if(e.done)continue;t=!0;const n=yield r(e.iter.next());n.done?e.done=!0:yield yield r(n.value)}if(!t)break}}))}())}mapAccum(t,e){const n=this;return new c(function(){return i(this,arguments,(function*(){var i,l;let a=e;try{for(var s,u=o(n);!(s=yield r(u.next())).done;){const e=s.value,[n,i]=yield r(t(a,e));yield yield r(i),a=n}}catch(t){i={error:t}}finally{try{s&&!s.done&&(l=u.return)&&(yield r(l.call(u)))}finally{if(i)throw i.error}}}))}())}async countIf(t){var e,n;let r=0;try{for(var i,l=o(this);!(i=await l.next()).done;){const e=i.value;await t(e)&&r++}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return r}scan(t,e){const n=this;return new c(function(){return i(this,arguments,(function*(){var i,l;let a;if(void 0===e){const t=yield r(n.next());if(t.done)throw new TypeError("Scan of empty iterator with no initializer.");a=t.value}else a=e;try{for(var s,u=o(n);!(s=yield r(u.next())).done;){const e=s.value;yield yield r(a),a=yield r(t(a,e))}}catch(t){i={error:t}}finally{try{s&&!s.done&&(l=u.return)&&(yield r(l.call(u)))}finally{if(i)throw i.error}}yield yield r(a)}))}())}async headEqualsBy(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(t.done||r.done)return!0;if(!await e(t.value,r.value))return!1}}async headEqualsWith(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(t.done||r.done)return!0;if(await e(t.value)!==await e(r.value))return!1}}async headEquals(t){const e=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),n=await e.next();if(t.done||n.done)return!0;if(t.value!==n.value)return!1}}async hasPrefixBy(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(r.done)return!0;if(t.done)return!1;if(!await e(t.value,r.value))return!1}}async hasPrefixWith(t,e){const n=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),r=await n.next();if(r.done)return!0;if(t.done)return!1;if(await e(t.value)!==await e(r.value))return!1}}async hasPrefix(t){const e=t[Symbol.asyncIterator]();for(;;){const t=await this.next(),n=await e.next();if(n.done)return!0;if(t.done)return!1;if(t.value!==n.value)return!1}}async allEqualBy(t){const e=await this.next();if(e.done)return!0;const n=e.value;for(;;){const e=await this.next();if(e.done)return!0;if(!await t(e.value,n))return!1}}async allEqualWith(t){const e=await this.next();if(e.done)return!0;const n=await t(e.value);for(;;){const e=await this.next();if(e.done)return!0;if(await t(e.value)!==n)return!1}}async allEqual(){const t=await this.next();if(t.done)return!0;const e=t.value;for(;;){const t=await this.next();if(t.done)return!0;if(t.value!==e)return!1}}nubBy(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const l=[];try{for(var a,s=o(e);!(a=yield r(s.next())).done;){const e=a.value;let n=!1;for(const i of l)if(yield r(t(e,i))){n=!0;break}n||(l.push(e),yield yield r(e))}}catch(t){n={error:t}}finally{try{a&&!a.done&&(i=s.return)&&(yield r(i.call(s)))}finally{if(n)throw n.error}}}))}())}nubWith(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;const l=new Set;try{for(var a,s=o(e);!(a=yield r(s.next())).done;){const e=a.value,n=yield r(t(e));l.has(n)||(l.add(n),yield yield r(e))}}catch(t){n={error:t}}finally{try{a&&!a.done&&(i=s.return)&&(yield r(i.call(s)))}finally{if(n)throw n.error}}}))}())}nub(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;const i=new Set;try{for(var l,a=o(t);!(l=yield r(a.next())).done;){const t=l.value;i.has(t)||(i.add(t),yield yield r(t))}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&(yield r(n.call(a)))}finally{if(e)throw e.error}}}))}())}async group(t){var e,n;const r={};try{for(var i,l=o(this);!(i=await l.next()).done;){const e=i.value,n=await t(e);n in r?r[n].push(e):r[n]=[e]}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return r}async tallyWith(t){var e,n;const r={};try{for(var i,l=o(this);!(i=await l.next()).done;){const e=i.value,n=await t(e);n in r?r[n]+=1:r[n]=1}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=l.return)&&await n.call(l)}finally{if(e)throw e.error}}return r}async tally(){var t,e;const n={};try{for(var r,i=o(this);!(r=await i.next()).done;){const t=r.value;t in n?n[t.toString()]+=1:n[t.toString()]=1}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=i.return)&&await e.call(i)}finally{if(t)throw t.error}}return n}globBy(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;let l=[];try{for(var a,s=o(e);!(a=yield r(s.next())).done;){const e=a.value;0===l.length||(yield r(t(l[l.length-1],e)))?l.push(e):(yield yield r(l),l=[e])}}catch(t){n={error:t}}finally{try{a&&!a.done&&(i=s.return)&&(yield r(i.call(s)))}finally{if(n)throw n.error}}l.length>0&&(yield yield r(l))}))}())}globWith(t){const e=this;return new c(function(){return i(this,arguments,(function*(){var n,i;let l,a=[];try{for(var s,u=o(e);!(s=yield r(u.next())).done;){const e=s.value,n=yield r(t(e));0===a.length||l===n?a.push(e):(yield yield r(a),a=[e]),l=n}}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=u.return)&&(yield r(i.call(u)))}finally{if(n)throw n.error}}a.length>0&&(yield yield r(a))}))}())}glob(){const t=this;return new c(function(){return i(this,arguments,(function*(){var e,n;let i=[];try{for(var l,a=o(t);!(l=yield r(a.next())).done;){const t=l.value;0===i.length||t===i[i.length-1]?i.push(t):(yield yield r(i),i=[t])}}catch(t){e={error:t}}finally{try{l&&!l.done&&(n=a.return)&&(yield r(n.call(a)))}finally{if(e)throw e.error}}i.length>0&&(yield yield r(i))}))}())}}e.AsyncIterPlus=c;class f extends c{constructor(t){super(t),this.storedVal={has:!1,val:void 0}}async next(){if(this.storedVal.has){const t=this.storedVal.val;return this.storedVal={has:!1,val:void 0},t}return await this.internal.next()}async peek(){return this.storedVal.has||(this.storedVal={has:!0,val:await this.internal.next()}),this.storedVal.val}}e.AsyncPeekable=f},143:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.CircularBuffer=void 0;class n{constructor(t=[]){const e=[];for(const n of t)e.push(n);const n=e.length;for(;e.length<32;)e.push(null);this.data=e,this.start=0,this.end=n%e.length,this.len=n}size(){return this.len}get(t){if(t<0||t>=this.size())throw new RangeError("Index out of bounds.");return this.data[(this.start+t)%this.data.length]}set(t,e){if(t<0||t>=this.size())throw new RangeError("Index out of bounds.");this.data[(this.start+t)%this.data.length]=e}*[Symbol.iterator](){for(let t=this.start;t!=this.end;t=(t+1)%this.data.length)yield this.data[t]}toArray(){return this.start<this.end?this.data.slice(this.start,this.end):[...this.data.slice(this.start),...this.data.slice(0,this.end)]}possiblyExpand(){if(this.size()>=this.data.length-1){const t=new Array(2*this.data.length);let e=0;for(const n of this)t[e]=n,e++;this.start=0,this.end=e,this.data=t}}possiblyShrink(){if(4*this.size()<=this.data.length){const t=new Array(Math.floor(this.data.length/2));let e=0;for(const n of this)t[e]=n,e++;this.start=0,this.end=e,this.data=t}}pushEnd(t){this.possiblyExpand(),this.data[this.end]=t,this.end=(this.end+1)%this.data.length,this.len++}pushStart(t){this.possiblyExpand(),this.start=(this.start-1+this.data.length)%this.data.length,this.data[this.start]=t,this.len++}popEnd(){if(0==this.size())throw new RangeError("Index out of bounds.");this.end=(this.end-1+this.data.length)%this.data.length;const t=this.data[this.end];return this.possiblyShrink(),this.len--,t}popStart(){if(0==this.size())throw new RangeError("Index out of bounds.");const t=this.data[this.start];return this.start=(this.start+1)%this.data.length,this.possiblyShrink(),this.len--,t}}e.CircularBuffer=n},715:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Peekable=e.IterPlus=e.nullVal=e.canIter=e.isIter=void 0;const r=n(143);e.isIter=function(t){return"object"==typeof t&&null!==t&&"function"==typeof t.next},e.canIter=function(t){return"string"==typeof t||"object"==typeof t&&null!==t&&Symbol.iterator in t},e.nullVal=null;class i{constructor(t){this.internal=t}next(){return this.internal.next()}nextVal(){const t=this.internal.next();return t.done?e.nullVal:t.value}[Symbol.iterator](){return this}static empty(){return new i(function*(){}())}static fromFunction(t){return new i(function*(){for(;;){const n=t();if(n===e.nullVal)break;yield n}}())}static onceWith(t){return new i(function*(){yield t()}())}static once(t){return new i(function*(){yield t}())}static repeatWith(t){return new i(function*(){for(;;)yield t()}())}static repeat(t){return new i(function*(){for(;;)yield t}())}static successors(t,n){return new i(function*(){let r=t;for(;r!==e.nullVal;)yield r,r=n(r)}())}static unfold(t,n){return new i(function*(){let r=n;for(;;){const n=t(r);if(n===e.nullVal)break;yield n[0],r=n[1]}}())}static cycle(t){return new i(function*(){const e=[];for(const n of t)yield n,e.push(n);for(;;)yield*e}())}static combinations(t,e=t.length){return new i(function*(){if(e>t.length||e<0)return;const n=[];for(let t=0;t<e;t++)n.push(t);for(;;){let e;for(yield n.map((e=>t[e])),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-e-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=n[n.length-e-2]+1,e--}}())}static combinationsWithRepetition(t,e=t.length){return new i(function*(){if(t.length<=0||e<0)return;const n=[];for(let t=0;t<e;t++)n.push(0);for(;;){let e;for(yield n.map((e=>t[e])),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=n[n.length-e-2],e--}}())}static permutations(t,e=t.length){return new i(function*(){if(e>t.length||e<0)return;if(0===e)return void(yield[]);const n=[],r=[];for(let e=0;e<t.length;e++)n.push(e);for(let n=t.length;n>t.length-e;n--)r.push(n);for(yield n.slice(0,e).map((e=>t[e]));;){let i;for(i=e-1;i>=0;i--){if(r[i]--,0!==r[i]){const o=n[i];n[i]=n[n.length-r[i]],n[n.length-r[i]]=o,yield n.slice(0,e).map((e=>t[e]));break}{const e=n[i];for(let t=i;t<n.length-1;t++)n[t]=n[t+1];n[n.length-1]=e,r[i]=t.length-i}}if(i<0)return}}())}static permutationsWithRepetition(t,e=t.length){return new i(function*(){if(t.length<=0||e<0)return;if(0===e)return void(yield[]);const n=[];for(let t=0;t<e;t++)n.push(0);for(;;){let e;for(yield n.map((e=>t[e])),e=0;e<n.length;e++)if(n[n.length-e-1]<t.length-1){n[n.length-e-1]++;break}if(e===n.length)break;for(e--;e>=0;)n[n.length-e-1]=0,e--}}())}static powerset(t){return new i(function*(){for(let e=0;e<=t.length;e++)yield*i.combinations(t,e)}())}static product(...t){return new i(function*(){if(t.length<=0)return;const e=[];for(let n=0;n<t.length;n++){if(0===t[n].length)return;e.push(0)}for(;;){let n;for(yield e.map(((e,n)=>t[n][e])),n=0;n<e.length;n++)if(e[t.length-n-1]<t[t.length-n-1].length-1){e[t.length-n-1]++;break}if(n===e.length)break;for(n--;n>=0;)e[t.length-n-1]=0,n--}}())}every(t){for(const e of this)if(!t(e))return!1;return!0}some(t){for(const e of this)if(t(e))return!0;return!1}concat(...t){const e=this;return new i(function*(){for(const n of[e,...t])for(const t of n)yield t}())}compareBy(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(t.done&&r.done)return 0;if(t.done)return-1;if(r.done)return 1;{const n=e(t.value,r.value);if(n<0)return-1;if(n>0)return 1}}}compareWith(t,e){return this.compareBy(t,(function(t,n){const r=e(t),i=e(n);return r<i?-1:r>i?1:0}))}compare(t){return this.compareBy(t,(function(t,e){return t<e?-1:t>e?1:0}))}collect(){const t=[];for(const e of this)t.push(e);return t}count(){let t=0;for(const e of this)t++;return t}enumerate(){const t=this;return new i(function*(){let e=0;for(const n of t)yield[e,n],e++}())}equalsBy(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(t.done&&r.done)return!0;if(t.done||r.done)return!1;if(!e(t.value,r.value))return!1}}equalsWith(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(t.done&&r.done)return!0;if(t.done||r.done)return!1;if(e(t.value)!==e(r.value))return!1}}equals(t){const e=t[Symbol.iterator]();for(;;){const t=this.next(),n=e.next();if(t.done&&n.done)return!0;if(t.done||n.done)return!1;if(t.value!==n.value)return!1}}filter(t){const e=this;return new i(function*(){for(const n of e)t(n)&&(yield n)}())}filterMap(t){const n=this;return new i(function*(){for(const r of n){const n=t(r);n!==e.nullVal&&(yield n)}}())}find(t){for(const e of this)if(t(e))return e;return e.nullVal}findMap(t){for(const n of this){const r=t(n);if(r!==e.nullVal)return r}return e.nullVal}flatten(){const t=this;return new i(function*(){for(const e of t)yield*e}())}map(t){const e=this;return new i(function*(){for(const n of e)yield t(n)}())}starmap(t){const e=this;return new i(function*(){for(const n of e)yield t(...n)}())}flatMap(t){const e=this;return new i(function*(){for(const n of e)yield*t(n)}())}reduce(t,e){let n;if(void 0===e){const t=this.next();if(t.done)throw new TypeError("Reduce of empty iterator with no initializer.");n=t.value}else n=e;for(const e of this)n=t(n,e);return n}forEach(t){for(const e of this)t(e)}fuse(){const t=this;return new i(function*(){for(const e of t)yield e}())}inspect(t){const e=this;return new i(function*(){for(const n of e)t(n),yield n}())}isPartitioned(t){let e=!1;for(const n of this)if(t(n)){if(e)return!1}else e=!0;return!0}isSortedBy(t){const e=this.next();if(e.done)return!0;let n=e.value;for(const e of this){if(t(n,e)>0)return!1;n=e}return!0}isSortedWith(t){const e=this.next();if(e.done)return!0;let n=t(e.value);for(const e of this){const r=t(e);if(n>r)return!1;n=r}return!0}isSorted(){return this.isSortedWith((t=>t))}last(){let t=e.nullVal;for(const e of this)t=e;return t}mapWhile(t){const e=this;return new i(function*(){for(const n of e){const e=t(n);if(null===e)break;yield e}}())}maxBy(t,e=!1){const n=this.next();if(n.done)return null;let r=n.value;for(const n of this){const i=t(n,r);(i>0||e&&0===i)&&(r=n)}return r}maxWith(t,e=!1){const n=this.next();if(n.done)return null;let r=n.value,i=t(r);for(const n of this){const o=t(n);(o>i||e&&o===i)&&(r=n,i=o)}return r}max(t=!1){return this.maxWith((t=>t),t)}minBy(t,e=!1){const n=this.next();if(n.done)return null;let r=n.value;for(const n of this){const i=t(n,r);(i<0||e&&0===i)&&(r=n)}return r}minWith(t,e=!1){const n=this.next();if(n.done)return null;let r=n.value,i=t(r);for(const n of this){const o=t(n);(o<i||e&&o===i)&&(r=n,i=o)}return r}min(t=!1){return this.minWith((t=>t),t)}nth(t){if(t<0)return e.nullVal;for(const e of this){if(t<=0)return e;t--}return e.nullVal}partition(t){const e=[],n=[];for(const r of this)t(r)?e.push(r):n.push(r);return[e,n]}peekable(){return new o(this)}findIndex(t){let e=0;for(const n of this){if(t(n))return e;e++}return-1}product(t=1){let e,n=!1;for(const t of this)n?e*=t:(e=t,n=!0);return void 0===e?t:e}sum(t=0){let e,n=!1;for(const t of this)n?e+=t:(e=t,n=!0);return void 0===e?t:e}reverse(){const t=[];for(const e of this)t.push(e);return new i(t.reverse().values())}skip(t){const e=this;return new i(function*(){for(let n=0;n<t;n++)if(e.next().done)return;yield*e}())}skipWhile(t){const e=this;return new i(function*(){for(;;){const n=e.next();if(n.done)return;if(!t(n.value)){yield n.value;break}}yield*e}())}take(t){const e=this;return new i(function*(){for(let n=0;n<t;n++){const t=e.next();if(t.done)return;yield t.value}}())}takeWhile(t){const e=this;return new i(function*(){for(;;){const n=e.next();if(n.done)return;if(!t(n.value))return;yield n.value}}())}unzip(){const t=[];for(const e of this){for(;e.length>t.length;)t.push([]);for(let n=0;n<e.length;n++)t[n].push(e[n])}return t}zipWith(t,...e){const n=this;return new i(function*(){const r=[n,...e.map((t=>t[Symbol.iterator]()))];for(;;){const e=[];for(const t of r){const n=t.next();if(n.done)return;e.push(n.value)}yield t(...e)}}())}zip(...t){const e=this;return new i(function*(){const n=[e,...t.map((t=>t[Symbol.iterator]()))];for(;;){const t=[];for(const e of n){const n=e.next();if(n.done)return;t.push(n.value)}yield t}}())}tee(t=2){if(t<=0)return[];const e=new r.CircularBuffer;let n=0,o=!1;const l=this,a=[],s=[];function*u(t){let r=0;for(;;){if(r>=n+e.size()){if(o)return;const t=l.next();if(t.done)return void(o=!0);e.pushEnd(t.value),yield t.value}else{yield e.get(r-n);const t=Math.min(...s);for(;t>n;)n++,e.popStart()}r++,s[t]=r}}for(let e=0;e<t;e++)s.push(0),a.push(new i(u(e)));return a}average(){let t=0,e=!1,n=!1,r=0;for(const i of this)e||("bigint"==typeof i&&(n=!0,t=BigInt(t)),e=!0),t+=i,r++;if(n&&(r=BigInt(r)),0===r)throw new RangeError("Cannot average an empty iterator.");return t/r}chunks(t){const e=this;return new i(function*(){for(;;){const n=[];for(let r=0;r<t;r++){const t=e.next();if(t.done)return void(n.length>0&&(yield n));n.push(t.value)}yield n}}())}chunksExact(t){const e=this;return new i(function*(){for(;;){const n=[];for(let r=0;r<t;r++){const r=e.next();if(r.done)return void(n.length===t&&(yield n));n.push(r.value)}yield n}}())}repeat(t){const e=this;return new i(function*(){const n=[];for(const t of e)n.push(t);if(0!==n.length)for(let e=0;e<t;e++)yield*n}())}rotateLeft(t){if(t<0)throw new RangeError("Cannot left rotate by a negative amount.");const e=this;return new i(function*(){const n=[];for(let r=0;r<t;r++){const r=e.next();if(r.done)return void(n.length>0&&(t%=n.length,yield*[...n.slice(t),...n.slice(0,t)]));n.push(r.value)}yield*e,yield*n}())}rotateRight(t){if(t<0)throw new RangeError("Cannot right rotate by a negative amount.");const e=this;return new i(function*(){const n=[];for(;;){const t=e.next();if(t.done)break;n.push(t.value)}n.length>0&&(t%=n.length,yield*[...n.slice(-t),...n.slice(0,-t)])}())}split(t,e=1/0){const n=this;return new i(function*(){const r=t;let i=!1,o=1,l=[];for(;;){const t=n.next();if(t.done){i&&(yield l);break}i=!0,o<e&&t.value===r?(yield l,l=[],o++):l.push(t.value)}}())}splitPred(t,e=1/0){const n=this;return new i(function*(){let r=!1,i=1,o=[];for(;;){const l=n.next();if(l.done){r&&(yield o);break}r=!0,i<e&&t(l.value)?(yield o,o=[],i++):o.push(l.value)}}())}splitInclusive(t,e=1/0){const n=this;return new i(function*(){const r=t;let i=!1,o=1,l=[];for(;;){const t=n.next();if(t.done){i&&l.length>0&&(yield l);break}i=!0,l.push(t.value),o<e&&t.value===r&&(yield l,l=[],o++)}}())}splitPredInclusive(t,e=1/0){const n=this;return new i(function*(){let r=!1,i=1,o=[];for(;;){const l=n.next();if(l.done){r&&o.length>0&&(yield o);break}r=!0,o.push(l.value),i<e&&t(l.value)&&(yield o,o=[],i++)}}())}windows(t,e=1){const n=this;return new i(function*(){const i=new r.CircularBuffer;for(let e=0;e<t;e++){const t=n.next();if(t.done)return;i.pushEnd(t.value)}for(;;){yield i.toArray();for(let t=0;t<e;t++){const t=n.next();if(t.done)return;i.popStart(),i.pushEnd(t.value)}}}())}dedup(){const t=this;return new i(function*(){const e=t.next();if(e.done)return;yield e.value;let n=e.value;for(const e of t)e!==n&&(yield e),n=e}())}dedupWith(t){const e=this;return new i(function*(){const n=e.next();if(n.done)return;yield n.value;let r=t(n.value);for(const n of e){const e=t(n);e!==r&&(yield n),r=e}}())}dedupBy(t){const e=this;return new i(function*(){const n=e.next();if(n.done)return;yield n.value;let r=n.value;for(const n of e)t(r,n)||(yield n),r=n}())}intersperse(t){const e=this;return new i(function*(){const n=t,r=e.next();if(!r.done){yield r.value;for(const t of e)yield n,yield t}}())}intersperseMultiple(t){const e=this;return new i(function*(){const n=[];for(const e of t)n.push(e);const r=e.next();if(!r.done){yield r.value;for(const t of e)yield*n,yield t}}())}join(t){const e=this;return new i(function*(){const n=t,r=e.next();if(!r.done){yield*r.value;for(const t of e)yield n,yield*t}}())}joinMultiple(t){const e=this;return new i(function*(){const n=[];for(const e of t)n.push(e);const r=e.next();if(!r.done){yield*r.value;for(const t of e)yield*n,yield*t}}())}toObject(t="overwrite"){const e={};for(const[n,r]of this)if("overwrite"!==t&&n in e){if("error"===t)throw new RangeError("Duplicate key encountered.");"maintain"===t||(e[n]=r)}else e[n]=r;return e}toMap(t="overwrite"){const e=new Map;for(const[n,r]of this)if("overwrite"!==t&&e.has(n)){if("error"===t)throw new RangeError("Duplicate key encountered.");"maintain"===t||e.set(n,r)}else e.set(n,r);return e}toSet(){const t=new Set;for(const e of this)t.add(e);return t}toArray(){const t=[];for(const e of this)t.push(e);return t}interleave(...t){const e=this;return new i(function*(){const n=[e,...t.map((t=>t[Symbol.iterator]()))].map((t=>({done:!1,iter:t})));for(;;){let t=!1;for(const e of n){if(e.done)continue;t=!0;const n=e.iter.next();n.done?e.done=!0:yield n.value}if(!t)break}}())}mapAccum(t,e){const n=this;return new i(function*(){let r=e;for(const e of n){const[n,i]=t(r,e);yield i,r=n}}())}countIf(t){let e=0;for(const n of this)t(n)&&e++;return e}scan(t,e){const n=this;return new i(function*(){let r;if(void 0===e){const t=n.next();if(t.done)throw new TypeError("Scan of empty iterator with no initializer.");r=t.value}else r=e;for(const e of n)yield r,r=t(r,e);yield r}())}headEqualsBy(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(t.done||r.done)return!0;if(!e(t.value,r.value))return!1}}headEqualsWith(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(t.done||r.done)return!0;if(e(t.value)!==e(r.value))return!1}}headEquals(t){const e=t[Symbol.iterator]();for(;;){const t=this.next(),n=e.next();if(t.done||n.done)return!0;if(t.value!==n.value)return!1}}hasPrefixBy(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(r.done)return!0;if(t.done)return!1;if(!e(t.value,r.value))return!1}}hasPrefixWith(t,e){const n=t[Symbol.iterator]();for(;;){const t=this.next(),r=n.next();if(r.done)return!0;if(t.done)return!1;if(e(t.value)!==e(r.value))return!1}}hasPrefix(t){const e=t[Symbol.iterator]();for(;;){const t=this.next(),n=e.next();if(n.done)return!0;if(t.done)return!1;if(t.value!==n.value)return!1}}allEqualBy(t){const e=this.next();if(e.done)return!0;const n=e.value;for(;;){const e=this.next();if(e.done)return!0;if(!t(e.value,n))return!1}}allEqualWith(t){const e=this.next();if(e.done)return!0;const n=t(e.value);for(;;){const e=this.next();if(e.done)return!0;if(t(e.value)!==n)return!1}}allEqual(){const t=this.next();if(t.done)return!0;const e=t.value;for(;;){const t=this.next();if(t.done)return!0;if(t.value!==e)return!1}}nubBy(t){const e=this;return new i(function*(){const n=[];for(const r of e){let e=!1;for(const i of n)if(t(r,i)){e=!0;break}e||(n.push(r),yield r)}}())}nubWith(t){const e=this;return new i(function*(){const n=new Set;for(const r of e){const e=t(r);n.has(e)||(n.add(e),yield r)}}())}nub(){const t=this;return new i(function*(){const e=new Set;for(const n of t)e.has(n)||(e.add(n),yield n)}())}group(t){const e={};for(const n of this){const r=t(n);r in e?e[r].push(n):e[r]=[n]}return e}tallyWith(t){const e={};for(const n of this){const r=t(n);r in e?e[r]+=1:e[r]=1}return e}tally(){const t={};for(const e of this)e in t?t[e.toString()]+=1:t[e.toString()]=1;return t}globBy(t){const e=this;return new i(function*(){let n=[];for(const r of e)0===n.length||t(n[n.length-1],r)?n.push(r):(yield n,n=[r]);n.length>0&&(yield n)}())}globWith(t){const e=this;return new i(function*(){let n,r=[];for(const i of e){const e=t(i);0===r.length||n===e?r.push(i):(yield r,r=[i]),n=e}r.length>0&&(yield r)}())}glob(){const t=this;return new i(function*(){let e=[];for(const n of t)0===e.length||n===e[e.length-1]?e.push(n):(yield e,e=[n]);e.length>0&&(yield e)}())}}e.IterPlus=i;class o extends i{constructor(t){super(t),this.storedVal={has:!1,val:void 0}}next(){if(this.storedVal.has){const t=this.storedVal.val;return this.storedVal={has:!1,val:void 0},t}return this.internal.next()}peek(){return this.storedVal.has||(this.storedVal={has:!0,val:this.internal.next()}),this.storedVal.val}}e.Peekable=o},179:function(t,e,n){var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)"default"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)};Object.defineProperty(e,"__esModule",{value:!0}),i(n(715),e),i(n(593),e),i(n(243),e)},243:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.asyncify=e.liftAsync=e.count=e.range=e.iterplus=void 0;const r=n(715),i=n(593);e.iterplus=function(t){if(r.canIter(t))return new r.IterPlus(t[Symbol.iterator]());if(i.canAsyncIter(t))return new i.AsyncIterPlus(t[Symbol.asyncIterator]());throw new Error("Object is not an iterable.")},e.range=function(t,e,n){let i,o=n;return"bigint"==typeof t?(void 0===n&&(o=BigInt(1)),i=BigInt(0)):(void 0===n&&(o=1),i=0),void 0===e&&(e=t,t=i),new r.IterPlus(function*(){let n=t;for(;;){if(void 0!==e){if(o<i&&n<=e)break;if(o>=i&&n>=e)break}yield n,n+=o}}())},e.count=function(t,e){let n=e;return"bigint"==typeof t&&void 0===e?n=BigInt(1):void 0===e&&(n=1),new r.IterPlus(function*(){let e=t;for(;;)yield e,e+=n}())},e.liftAsync=function(t){const e=t[Symbol.iterator]();return new i.AsyncIterPlus({next:()=>Promise.resolve(e.next())})},e.asyncify=function(t){return async function(...e){return t(...e)}}}},e={};return function n(r){if(e[r])return e[r].exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}(179)})();